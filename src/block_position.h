/* Copyright 2012 Brian Ellis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef BLOCK_POSITION_H
#define BLOCK_POSITION_H

#include <QVector3D>
#include <QDebug>

/**
  * A lightweight integer-precision position class for blocks.  Because there can only be one block in a given square
  * meter, it is more efficient and convenient to use integers for block coordinates (they hash correctly, can be
  * compared without worrying about roundoff errors, etc).  When the block is rendered, a (real-valued) QVector3D is
  * required, and this can be generated by calling either cornerVector() or centerVector().  For efficiency, these
  * vectors are not calculated until they are needed, so creating and copying BlockPositions is fairly cheap.
  */
class BlockPosition {
 public:
  BlockPosition();

  /** Constructs a BlockPosition with the given x, y, and z coordinates. */
  BlockPosition(int x, int y, int z);

  /**
   * Copy constructor. If the corner and center vectors have already been computed, they will be copied to the new
   * instance as well.
   */
  BlockPosition(const BlockPosition& other);

  /**
    * Constructs a BlockPosition from a QVector3D.  This involves some floating point math, so it is more expensive
    * than the other constructors.
    */
  explicit BlockPosition(const QVector3D& vector);

  /**
    * Assigns one BlockPosition to another.  As with the copy constructor, this will copy the corner and center vectors
    * to the new instance if they have been computed.
    */
  BlockPosition& operator=(const BlockPosition& other);

  /** Equality operator.  Because BlockPosition is integer-valued, this is both fast and always accurate. */
  bool operator==(const BlockPosition& other) const;

  /** Adds two BlockPositions component-wise and returns the result. */
  BlockPosition operator+(const BlockPosition& other) const;

  /** Returns the x component of this BlockPosition. */
  inline int x() const {
    return x_;
  }

  /** Returns the y component of this BlockPosition. */
  inline int y() const {
    return y_;
  }

  /** Returns the y component of this BlockPosition. */
  inline int z() const {
    return z_;
  }

  /** Returns the vector pointing to this BlockPosition's front lower left corner. */
  const QVector3D& cornerVector() const;

  /** Returns the vector pointing to this BlockPosition's center. */
  const QVector3D& centerVector() const;

 private:
  /**
   * Computes the corner and center vectors for this BlockPosition.
   * This is fairly expensive, so it is called only when needed.
   */
  void computeVectors() const;

  int x_;
  int y_;
  int z_;
  mutable bool vectors_known_;
  mutable QVector3D corner_vector_;
  mutable QVector3D center_vector_;
};

/**
  * Allows BlockPositions to be streamed using qDebug().
  */
QDebug operator<<(QDebug dbg, const BlockPosition& position);

/**
  * Allows BlockPositions to be efficiently stored in a hash table such as QHash.  This hash function is designed such
  * that two identical BlockPositions will always hash to the same value with no floating-point nonsense.
  */
uint qHash(const BlockPosition& vec);

#endif // BLOCK_POSITION_H
